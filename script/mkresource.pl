#! /usr/bin/perl

# Read resources and make a class encapsulating all the tedious getString(),
# R.id.... blahblah stuff.  The binders are awkward.  Using the stuff
# manually feels last millenium, and is not typesafe.

use strict;
use warnings;
use autodie;
use utf8;
use open qw(:std :utf8);
use Carp;
use Data::Dumper;
use XML::LibXML;
use IO::Compress::Gzip qw(gzip $GzipError);

use constant IND => '    ';
my $auto_text = 'Autogenerated by mkresource.pl, do not edit';

my $en_US = 'en-US';
my $lang_default = 'default';
my $do_gz = 0;

$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;

sub read_file($)
{
    my ($fn) = @_;
    print STDERR "R $fn\n";
    open(my $f, '<', $fn);
    local $/ = undef;
    return <$f>;
}

sub write_file($$)
{
    my ($fn, $text) = @_;
    print STDERR "W $fn\n";
    croak "No text to save" unless defined $text;
    open(my $f, '>', "$fn.new");
    print { $f } $text;
    close ($f);
    rename ("$fn.new", $fn);
}

sub write_file_gz($$)
{
    my ($fn, $text) = @_;
    my $bytes = $text;
    utf8::encode($bytes);
    print STDERR "W $fn\n";
    croak "No text to save" unless defined $text;
    gzip \$bytes => "$fn.new" or die "ERROR: $fn: GZIP failed\n";
    rename ("$fn.new", $fn);
}

sub mkdir_p($);
sub mkdir_p($)
{
    my ($s) = @_;
    return if -d $s;
    die "ERROR: '$s' is not a directory" if -e $s;

    $s =~ s(/+)(/)g;
    $s =~ s(/+$)();
    if ($s =~ m(^(.+)/[^/]+$)) {
        mkdir_p($1);
    }
    print STDERR "D $s\n";
    mkdir $s, 0777;
}

sub the_one_or_null(@)
{
    confess "multiple nodes" if @_ > 1;
    my ($x) = @_;
    return $x;
}

sub the_one(@)
{
    return &the_one_or_null // confess "no node";
}

sub snake_case($)
{
    my ($x) = @_;
    confess unless defined $x;
    $x =~ s/([a-z])([A-Z])/${1}_${2}/g;
    return lc($x);
}

sub SNAKE_CASE($)
{
    my ($x) = @_;
    confess unless defined $x;
    return uc(snake_case($x));
}

sub CamelCase($)
{
    my ($x) = @_;
    confess unless defined $x;
    return join('', map { ucfirst($_) } split /_/, $x);
}

sub camelCase($)
{
    my ($x) = @_;
    return lcfirst(CamelCase($x));
}

######################################################################

sub base_dir()
{
    my $d = '.';
    while (-d $d) {
        return $d if (-d "$d/res") && (-d "$d/java");
        my $main = "$d/app/src/main";
        return $main if (-d "$main/res") && (-d "$main/java");
        $d .= "/..";
    }
    die "ERROR: Unable to find ./.../app/src/main/{res,java} dirs\n";
}

sub java_dir($);
sub java_dir($)
{
    my ($dir) = @_;
    my @e =
        map { "$dir/$_" }
        grep { $_ !~ m/^[.]/ }
        sort
        do {
            opendir(my $d, $dir);
            readdir($d);
        };
    my @d = grep { -d $_ } @e;
    my @j = grep { (-f $_) && ($_ =~ m([.](?:java|kt)$)) } @e;

    return $dir if @j > 0;
    return java_dir($d[0]) if @d == 1;
    return "$dir/res";
}

sub init_dirs($)
{
    my ($C) = @_;
    $C->{base_dir} = base_dir();
    $C->{res_dir} = "$C->{base_dir}/res";
    $C->{top_java_dir} = "$C->{base_dir}/java";
    $C->{java_dir} = java_dir($C->{top_java_dir});
    $C->{top_dir} = "$C->{base_dir}/../../..";
    $C->{meta_dir} = "$C->{top_dir}/metadata";
    $C->{meta_en} = "$C->{meta_dir}/$en_US";

    unless (-d "$C->{meta_en}") {
        die "ERROR: '$C->{meta_en}' not found or no directory";
    }

    (my $subdir = $C->{java_dir}) =~ s(^\Q$C->{top_java_dir}/\E)() or
        die "ERROR: No subdir for Java/Kotlin files in '$C->{top_java_dir}'\n";
    ($C->{pack} = $subdir) =~ s(/)(.)g;
}

######################################################################

{
    my $uniq = 0;
    sub uniq()
    {
        return ++$uniq;
    }
}

sub max(@)
{
    my $r = shift;
    for my $s (@_) {
        $r = $s if $r < $s;
    }
    return $r;
}

sub trim($)
{
    my ($s) = @_;
    confess unless defined $s;
    $s =~ s(^\s+)()s;
    $s =~ s(\s+$)()s;
    return $s;
}

sub normalize_space($)
{
    my ($s) = @_;
    confess unless defined $s;
    $s =~ s(\s+)( )gs;
    return trim($s);
}

sub normalize_space_par($)
{
    my ($s) = @_;
    confess unless defined $s;
    $s =~ s(\s*\n{2,}\s*)(\0)g;
    $s =~ s(\s+)( )gs;
    $s =~ s(\0)(\n\n)gs;
    return trim($s);
}

sub com(\@)
{
    my ($c) = @_;
    my @t = @$c;
    @$c = ();
    return join("\n", map { trim($_) } @t);
}

sub learn_res_node($$$$$$)
{
    my ($C, $fn, $dom, $type, $def, $com) = @_;
    my $name = $def->getAttribute('name') or die "$fn: ERROR: $type node without name\n";
    my $uniq = uniq;
    my $e = ($C->{resource}{$type}{$name} //= { type => $type, name => $name, uniq => $uniq });
    $e->{com}{$fn} = $com;
    $e->{uniqs}{$fn} = $uniq;
    my $attrs = { map { ($_->nodeName => $_->value) } $def->attributes };
    delete $attrs->{name};
    while (my ($k0,$v) = each %$attrs) {
        (my $k = $k0) =~ s(^.*:)();
        $e->{attr}{$k}{$fn} = $v;
    }

    my $text = '';
    my $child_i = 0;
    my @com = ();
    for my $child ($def->childNodes) {
        my $kind = $child->nodeType;
        if ($kind == XML_COMMENT_NODE) {
            push @com, normalize_space_par($child->data);
        }
        elsif ($kind == XML_TEXT_NODE) {
            $text .= $child->data; # Android unquoting (\', \n, etc.) not done here!
        }
        elsif ($kind == XML_ELEMENT_NODE) {
            my $type2 = $child->nodeName;
            my $g = ($e->{child}{$type2}[$child_i++]{$fn} //= { type => $type2, com=>com(@com) });
            for my $a ($child->attributes) {
                $g->{attr}{$a->nodeName} = $a->value;
            }
            my $text2 = '';
            for my $child2 ($child->childNodes) {
                my $kind2 = $child2->nodeType;
                if ($kind2 == XML_COMMENT_NODE) {
                }
                elsif ($kind2 == XML_TEXT_NODE) {
                    $text2 .= $child2->data;   # Android unquoting (\', \n, etc.) not done here!
                }
                else {
                    die "$fn: ERROR: Unrecognised child node of $type.$type2: type='$kind2'\n";
                }
            }
            $g->{text} = $text2;
        }
        else {
            die "$fn: ERROR: Unrecognised child node of $type: type='$kind'\n";
        }
    }

    $e->{text}{$fn} = $text;
}

{
    my %learn_cb = (
        attr         => \&learn_res_node,
        string       => \&learn_res_node,
        dimen        => \&learn_res_node,
        color        => \&learn_res_node,
        style        => \&learn_res_node,
        array        => \&learn_res_node,
        string_array => \&learn_res_node,
    );

    sub learn_res_resources($$$)
    {
        my ($C, $fn, $dom) = @_;
        my ($root) = $dom->childNodes;
        my @com = ();
        for my $def ($root->childNodes) {
            if ($def->nodeType == XML_COMMENT_NODE) {
                push @com, normalize_space_par($def->data);
            }
            elsif ($def->nodeType == XML_ELEMENT_NODE) {
                (my $type = $def->nodeName) =~ s(-)(_)g;
                if (my $cb = $learn_cb{$type}) {
                    $cb->($C, $fn, $dom, $type, $def, com(@com));
                }
                else {
                    print STDERR "$fn: WARNING: Unrecognised resource type: '$type'\n";
                }
            }
        }
    }
}

# Android does not seem to really care about namespaces, so we'll just ignore them.
sub parse_attr($$)
{
    my ($n, $d) = @_;
    for my $a ($d->attributes) {
        my $k = $a->nodeName;
        my $v = $a->value;
        if ($k eq 'xmlns') {
        }
        elsif ($k =~ m(^xmlns:(.+)$)) {
        }
        elsif ($k =~ m(^(.+):(.+)$)) {
            croak "ERROR: duplicate attribute '$2'" if defined $n->{attr}{$2};
            $n->{attr}{$2} = $v;
        }
        else {
            croak "ERROR: duplicate attribute '$k'" if defined $n->{attr}{$k};
            $n->{attr}{$k} = $v;
        }
    }
}

sub learn_res_layout_rec($$);
sub learn_res_layout_rec($$)
{
    my ($L, $d) = @_;
    return unless $d->nodeType == XML_ELEMENT_NODE;

    my $n = { type => $d->nodeName };
    parse_attr($n, $d);

    if ($n->{attr}{id} && ($n->{attr}{id} =~ m(^\@\+id/(.+)$))) {
        my $id = $1;
        $n->{id} = $id;
        croak "ERROR: duplicate id '$id'" if defined $L->{node}{$id};
        $L->{node}{$id} = $n;
    }

    for my $child ($d->childNodes) {
        if (my $u = learn_res_layout_rec($L, $child)) {
            push @{ $n->{child} }, $u;
        }
    }

    return $n;
}

sub learn_res_layout($$$$)
{
    my ($C, $fn, $name, $dom) = @_;
    my $L = ($C->{resource}{layout}{$name} //= { name => $name, dom => $dom, uniq => uniq });
    $L->{root} = learn_res_layout_rec($L, the_one($dom->childNodes));
}

sub learn_res_xml($$)
{
    my ($C, $fn) = @_;
    return if $fn =~ m(\bauto-);
    print STDERR "R $fn (XML)\n";
    my $dom = XML::LibXML->load_xml(location => $fn);
    my ($root) = $dom->childNodes;
    my $rootName = $root->nodeName;
    if ($rootName eq 'resources') {
        return learn_res_resources($C, $fn, $dom);
    }
    if (($rootName eq 'adaptive-icon') ||
        ($rootName eq 'vector'))
    {
        # graphics are currently ignored
        return;
    }
    if ($fn =~ m(res/layout/([^/]+)[.]xml$)) {
        return learn_res_layout($C, $fn, $1, $dom);
    }
    if ($fn =~ m(res/xml/([^/]+)[.]xml$)) {
        # current, ignore these
        return;
    }
    die "ERROR: Unknown tag: $fn : ".$root->nodeName;
}

sub learn_res_rec($$);
sub learn_res_rec($$)
{
    my ($C, $dir) = @_;
    for my $e (sort do { opendir(my $d, $dir); readdir($d) }) {
        next if $e =~ m(^[.]);
        my $full = "$dir/$e";
        if (-d $full) {
            learn_res_rec($C, $full);
        }
        elsif ((-f $full) && ($e =~ m([.]xml$))) {
            learn_res_xml($C, $full);
        }
    }
}

sub learn_resources($)
{
    my ($C) = @_;
    learn_res_rec($C, $C->{res_dir});
}

######################################################################

sub has_value($$)
{
   my ($m, $k) = @_;
   return (grep { $_ eq $k } values %$m) > 0;
}

sub make_enums($)
{
    my ($C) = @_;
    my $M = {};
    my $R = $C->{resource};
    for my $k (
        sort
        grep { has_value($_->{attr}{translatable}, 'false') }
        values %{ $R->{string_array} })
    {
        my $name = $k->{name};
        (my $pref = $name) =~ s((_choice|_key)+$)();
        # print "DEBUG: string_array non-translatable '$k->{name}' -> '$pref'\n";
        my @item = map { my ($v) = values %$_; $v->{text} } @{ $k->{child}{item} // [] };
        for my $i (0..$#item) {
            my $v = $item[$i];
            (my $q = $v) =~ s([^0-9a-z]+)(_)gi;
            $q =~ s(^_+)();
            $q =~ s(_+$)();
            # print "DEBUG: '$name' '$pref' $i '$v' '$q'\n";
            push @{ $M->{const} }, {
                order => "$name $i",
                value => $i,
                enum => $name,
                key => "${pref}_$q",
            };
        }
    }
    return $M;
}

######################################################################

sub lexnum_cmp($$)
{
    my ($x, $y) = @_;
    my @x = split /(\d+)/, $x;
    my @y = split /(\d+)/, $y;
    while (@x && @y) {
        my $x0 = ($x[0] =~ /^\d/) ? (shift @x) : '';
        my $y0 = ($y[0] =~ /^\d/) ? (shift @y) : '';
        if (($x0 ne '') || ($y0 ne '')) {
            return ($x0 <=> $y0) || ($x0 cmp $y0) || next;
        }
        $x0 = shift @x;
        $y0 = shift @y;
        (my $x1 = $x0) =~ s([^a-z])()gi;
        (my $y1 = $y0) =~ s([^a-z])()gi;
        return (lc($x1) cmp lc($y1)) || ($x1 cmp $y1) || ($x0 cmp $y0) || next;
    }
    return @x <=> @y;
}

sub make_enum_kotlin($$)
{
    my ($C, $M) = @_;

    my $t = "package $C->{pack}\n\n";
    for my $c (sort { lexnum_cmp($a->{order}, $b->{order}) } @{ $M->{const} }) {
        my $k = $c->{key};
        my $v = $c->{value};
        $t .= "const val $k = $v\n";
    }
    return $t;
}

######################################################################

sub idx($@)
{
    my $x = shift;
    for my $i (@_) {
        return unless defined($x) && defined($i);
        if (ref($x) eq 'HASH') {
            $x = $x->{$i};
        }
        elsif (ref($x) eq 'ARRAY') {
            $x = $x->[$i];
        }
        else {
            die "ERROR: Cannot index '$x'" unless ref($x);
        }
    }
    return $x;
}

sub normalize_lines($)
{
    my ($s) = @_;
    confess unless defined $s;
    my @s = map { normalize_space($_)."\n" } split /\n/, $s;
    $s = join('', @s);
    $s =~ s(\n\n+)(\n\n)g;
    return trim($s);
}

sub text_unwrap($)
{
    my ($s) = @_;
    confess unless defined $s;
    my @s = map { normalize_space($_)."\n" } split /\n\n+/, $s;
    $s = join("\n", @s);
    return $s;
}

sub text_list($)
{
    my ($s) = @_;
    confess unless defined $s;
    my @s = map { "  $_\n" } split /\n/, $s;
    $s = join('', @s);
    return $s;
}

######################################################################

sub path2lang($)
{
    my ($p) = @_;
    if ($p =~ m(/values(?:-([^/]+))?/)) {
        return $1 // $lang_default;
    }
    croak "ERROR: Unable to map '$p' to a language code\n";
}

sub lang_map($)
{
    my ($r) = @_;
    return { map { (path2lang($_) => $_) } keys %$r };
}

sub get_lang($$;$)
{
    my ($r, $l, $default) = @_;
    $l = $lang_default if $l eq '';
    my $lang = lang_map($r);
    my $q0 = $lang->{$lang_default};
    my $q1 = $lang->{$l};
    return
        (defined($q1) ? $r->{$q1} : undef)
        // $default
        // (defined($q0) ? $r->{$q0} : undef)
        // croak "ERROR: No text nor default for '$l' in ".Dumper($r);
}

sub get_string($$;$)
{
    my ($C, $k, $l) = @_;
    my $S = $C->{resource}{string};
    my $r = $S->{$k}{text} // die "ERROR: README/Metadata: Missing string: '$k'\n";
    if (defined $l) {
        return get_lang($r, $l);
    }
    return $r;
}

sub get_string_array($$)
{
    my ($C, $k) = @_;
    return $C->{resource}{string_array}{$k}
}

sub get_attr($$;$$)
{
    my ($item, $k, $l, $default) = @_;
    my $A = $item->{attr} // return undef;
    my $r = $A->{$k} // return undef;
    if (defined $l) {
        return get_lang($r, $l, $default);
    }
    return $r;
}

sub make_metadata($)
{
    my ($C) = @_;

    # read doc strings
    my $title = get_string($C, 'app_name');
    my $short_desc = get_string($C, 'readme_short_description');
    my $desc_head = get_string($C, 'readme_description');
    my $full_desc = get_string($C, 'readme_full_description');
    my $feat_head = get_string($C, 'readme_features');
    my $feat_list = get_string($C, 'readme_feature_list');
    my $shot_head = get_string($C, 'readme_screenshots');

    # learn languages
    my %lang = ();
    for my $s ($title, $short_desc, $desc_head, $full_desc, $feat_head, $feat_list) {
        for my $k (sort keys %$s) {
            if ($k =~ m(/values(?:-([^/]+))?/)) {
                my $l = $1 // $en_US;
                $lang{$l} = { key => $k };
            }
        }
    }
    die "ERROR: No default language string found (for '$en_US' metadata)"
        unless $lang{$en_US};
    die if $C->{lang};

    # generate metadata and prepare readme
    my $readme = '';
    my $lang_en_key = undef;
    for my $lang (sort keys %lang) {
        my $k = $lang{$lang}{key};
        my $k2 = $lang{$en_US}{key};

        my $_title = normalize_space($title->{$k}      // $title->{$k2}      );
        my $_short = normalize_space($short_desc->{$k} // $short_desc->{$k2} );
        my $_desc  = normalize_space($desc_head->{$k}  // $desc_head->{$k2}  );
        my $_full  = normalize_lines($full_desc->{$k}  // $full_desc->{$k2}  );
        my $_feat  = normalize_space($feat_head->{$k}  // $feat_head->{$k2}  );
        my $_list  = normalize_lines($feat_list->{$k}  // $feat_list->{$k2}  );
        my $_list2 = text_list($_list);

        mkdir_p("$C->{meta_dir}/$lang");
        write_file("$C->{meta_dir}/$lang/title.txt", "$_title\n");
        write_file("$C->{meta_dir}/$lang/short_description.txt", "$_short\n");

        my $_full2 = text_unwrap($_full);
        my $_full3 = "${_full2}\n\n${_feat}:\n\n${_list2}\n";
        $_full3 =~ s(\n\n+)(\n\n)g;
        write_file("$C->{meta_dir}/$lang/full_description.txt", $_full3);

        if ($lang eq $en_US) {
            $lang_en_key = $k;
            $readme = "# $_title\n\n";
            $readme .= "$_short\n\n";
            $readme .= "## $_desc\n\n";
            $readme .= "$_full\n\n";
            $readme .= "## $_feat\n\n";
            $readme .= "$_list2\n\n";

            $readme =~ s(\n\n+)(\n\n)g;
            $readme =~ s(\n+$)();
            $readme .= "\n";
        }
    }

    # Translation link:
    $readme .= qq(\n[Help Translate!](http://henrik.theiling.de/neatlauncher/TRANSLATE.html)\n);

    # F-Droid link
    $readme .= qq{\n[<img src="https://f-droid.org/badge/get-it-on.png"
        alt="Get it on F-Droid" height="80">](https://f-droid.org/packages/$C->{pack}/)\n};

    # find screenshot images
    my @img = ();
    my $dir = "$C->{meta_en}/images/phoneScreenshots";
    for my $i (sort do { opendir(my $d, $dir); readdir($d); }) {
        next if $i =~ m(^[.]);
        next unless $i =~ m([.](?:png|jpg)$);
        next unless -f "$dir/$i";
        (my $rel = "$dir/$i") =~ s(^\Q$C->{top_dir}\E/?)();
        push @img, $rel;
    }

    # add images to README
    if (@img) {
        my $_shot = normalize_space($shot_head->{$lang_en_key});
        $readme .= "\n## $_shot\n\n";
        for my $img (@img) {
            (my $name = $img) =~ s(^.*/)()g;
            $readme .= "![image $name]($img)\n";
        }
    }

    # write readme
    write_file("$C->{top_dir}/README.md", $readme);
}

######################################################################

my %pack_of = (
    View => 'android.view',
    ViewGroup => 'android.view',
);

sub make_binding($$)
{
    my ($C, $pack) = @_;

    my %class = ();
    my %import = map { ($_ => 1) } qw (
        android.view.LayoutInflater
        android.view.View
        android.view.ViewGroup
    );

    $class{ViewBinding} =
        "interface ViewBinding {\n".
        "\tval root: View\n".
        "}\n";

    for my $n (sort { $a->{name} cmp $b->{name} } values %{ $C->{resource}{layout} // {} }) {
        next unless ($n->{root}{attr}{viewBindingIgnore} // 'false') eq 'false';
        my $ccname = CamelCase($n->{name});
        my $class = "${ccname}Binding";

        my %node = %{ $n->{node} // {} };
        my $root = $n->{root};
        unless ($root->{id}) {
            $root->{id} = 'root_view';
            $node{rootView} = $root;
            $root->{is_prop} = 0;
        }

        for my $n (values %node) {
            $n->{ltype} = $n->{type};
            if ($n->{type} =~ m(^(.+)[.]([^.]+)$)) {
                $n->{pack} = $1;
                $n->{ltype} = $2;
            }
            $n->{pack} //= $pack_of{$n->{ltype}} // 'android.widget';
            $n->{qtype} = "$n->{pack}.$n->{ltype}";
            if ($n->{pack} ne $pack) {
                $import{$n->{qtype}} = 1;
            }
            $n->{name} = camelCase($n->{id});
            $n->{is_prop} //= 1;
        }
        my @node = ($root,
            (grep { $_ != $root } sort { $a->{id} cmp $b->{id} } values %node));

        my $param_str = join(',',
            map {
                my $e = $_;
                my $val = $e->{is_prop} ? "val " : "";
                "\n\t$val$e->{name}: $e->{ltype}"
            } @node);

        my $get_str = join(',',
            map {
                my $e = $_;
                my $g = ($e == $root) ? "rootView as $e->{ltype}" :
                    "rootView.findViewById(R.id.$e->{id})!!";
                "\n\t\t\t$g"
            } @node);
        my $kt = '';
        $kt .= "class $class($param_str):\n\tViewBinding\n{\n";
        $kt .= "\toverride val root = $root->{name}\n";

        # arrays:
        my %arr = ();
        for my $e (@node) {
            if ($e->{name} =~ m(^(.+)(\d)$)) {
                my ($base, $idx) = ($1,$2);
                my $a = ($arr{$base} //= { base => $base, idx_cnt => 0 });
                $a->{idx}{$idx} = $e;
                $a->{idx_cnt}++;
                $a->{idx_min} = $idx if $idx <= ($a->{idx_min} // $idx);
                $a->{idx_max} = $idx if $idx >= ($a->{idx_max} // $idx);
                $a->{ltype}{$e->{ltype}} = 1;
            }
        }
        for my $base (sort keys %arr) {
            my $a = $arr{$base};
            next if $a->{idx_cnt} < 2;
            next if $a->{idx_min} != 0;
            next if $a->{idx_max} != ($a->{idx_cnt} - 1);
            my @ltype = keys %{ $a->{ltype} };
            next if scalar(@ltype) != 1;
            my ($ltype) = @ltype;
            my @them = map { $a->{idx}{$_}{name} } 0..$a->{idx_max};
            my $them = join(", ", @them);
            $kt .= "\tval $base = arrayOf($them)\n";
        }

        # construction:
        $kt .= "\tcompanion object {\n";

        $kt .= "\t\tfun bind(rootView: View) = $class($get_str)\n\n";

        $kt .= "\t\tfun inflate(\n";
        $kt .= "\t\t\tinflater: LayoutInflater,\n";
        $kt .= "\t\t\tparent: ViewGroup?,\n";
        $kt .= "\t\t\tattachToParent: Boolean): $class\n";
        $kt .= "\t\t{\n";
        $kt .= "\t\t\tval root = inflater.inflate(R.layout.$n->{name}, parent, false)\n";
        $kt .= "\t\t\tif (attachToParent) parent?.addView(root)\n";
        $kt .= "\t\t\treturn bind(root)\n";
        $kt .= "\t\t}\n\n";

        $kt .= "\t\t\@Suppress(\"unused\")\n";
        $kt .= "\t\tfun inflate(inflater: LayoutInflater) = inflate(inflater, null, false)\n";

        $kt .= "\t}\n";
        $kt .= "}\n";
        $kt =~ s(\t)(IND)eg;
        $class{$class} = $kt;
    }

    my $kt =
        "\@file:Suppress(\"MemberVisibilityCanBePrivate\")\n".
        "\n".
        "package $pack\n\n".
        join("\n", map { "import $_" } sort keys %import)."\n\n".
        join("\n", map { $class{$_} } sort keys %class);

   return $kt;
}

######################################################################

sub add_style($$)
{
    my ($C, $e) = @_;
    my $st = $C->{resource}{style}{"AppTheme.$e->{key}"} //
        die "ERROR: No style variant AppTheme.$e->{key} found for theme generation\n";
    $e->{style} = $st;
    return $e;
}

sub make_themes($$)
{
    my ($C, $M) = @_;

    my @const = (
        map {
            my $e = $_;
            (my $key = $e->{key}) =~ s(^.*_)();
            {
                enum => $e->{enum},
                key => $key,
                long_key => $e->{key},
                case_key => $e->{value} ? $e->{key} : 'else',
                case_order => $e->{value} || 999999,
            }
        }
        @{ $M->{const} });

    my @back  = (map { add_style($C, $_) } grep { $_->{enum} eq 'back_choice_key' } @const);
    my @font  = (map { add_style($C, $_) } grep { $_->{enum} eq 'font_choice_key' } @const);
    my @color = (map { add_style($C, $_) } grep { $_->{enum} eq 'color_choice_key'} @const);

    my $t = '';
    $t .= "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
    $t .= "<!-- $auto_text -->\n";
    $t .= "<resources>\n";
    for my $back (@back) {
        for my $font (@font) {
            $t .= "\t<style name=\"AppTheme.$back->{key}.$font->{key}\">\n";
            for my $item_var (@{ $font->{style}{child}{item} // [] }) {
                my ($item) = values %$item_var;
                my $name = $item->{attr}{name};
                my $value = $item->{text};
                $t.= "\t\t<item name=\"$name\">$value</item>\n";
            }
            $t .= "\t</style>\n";
            for my $color (@color) {
                $t .= "\t<style name=\"AppTheme.$back->{key}.$font->{key}.$color->{key}\">\n";
                for my $item_var (@{ $color->{style}{child}{item} // [] }) {
                    my ($item) = values %$item_var;
                    my $name = $item->{attr}{name};
                    my $value = $item->{text};
                    $t.= "\t\t<item name=\"$name\">$value</item>\n";
                }
                $t .= "\t</style>\n";
            }
        }
    }
    $t .= "</resources>\n";
    $t =~ s(\t)(IND)eg;

    my $k = '';
    $k .= "package $C->{pack}\n\n";
    $k .= "fun selectTheme(back: Int, font: Int, color: Int) = when (back) {\n";
    for my $back (sort { $a->{case_order} <=> $b->{case_order} } @back) {
        $k .= "\t$back->{case_key} -> when (font) {\n";
        for my $font (sort { $a->{case_order} <=> $b->{case_order} } @font) {
            $k .= "\t\t$font->{case_key} -> when (color) {\n";
            for my $color (sort { $a->{case_order} <=> $b->{case_order} } @color) {
                my $n = join('_', 'AppTheme', $back->{key}, $font->{key}, $color->{key});
                $k .= "\t\t\t$color->{case_key} -> R.style.$n\n";
            }
            $k .= "\t\t}\n";
        }
        $k .= "\t}\n";
    }
    $k .= "}\n";
    $k =~ s(\t)(IND)eg;

    return {
        style => $t,
        kotlin => $k
    };
}

######################################################################

sub wrap_line($$)
{
    my ($s, $width) = @_;
    my @w = split /\s+/, $s;
    my @l = ();
    my $l = '';
    for my $w (@w) {
        if ($l eq '') {
            $l = $w;
            next;
        }
        elsif ((length($l) + 1 + length($w)) <= $width) {
            $l .= " $w";
            next;
        }
        else {
            push @l, $l;
            $l = '';
            redo;
        }
    }
    push @l, $l if $l ne '';
    return join("\n", @l);
}

sub export_newline($)
{
    my ($txt) = @_;
    $txt =~ s(^\s+)();
    $txt =~ s(\s+$)();
    my $kind = '';
    if ($txt =~ m(\\n)) {
        $txt =~ s(\n+)( )g;
        $txt =~ s(\\n\n?)(\n)g;
        $kind = '-'; # pre-line
    }
    elsif ($txt =~ m(\n\n)) {
        $txt =~ s(\n{2,})(\\n)g;
        $txt =~ s(\n)( )g;
        $txt =~ s(\\n\n?)(\n\n)g;
    }
    $txt =~ s(^[ \t]+)()gm;
    $txt =~ s(^\s+)();
    $txt =~ s(\s+$)();
    return ($kind, $txt);
}

sub quote_html($)
{
    my ($s) = @_;
    $s =~ s(\&)(&amp;)g;
    $s =~ s(\")(&quot;)g;
    $s =~ s(<)(&lt;)g;
    $s =~ s(>)(&gt;)g;
    return $s;
}

# This quotation stuff is basically broken -- we're not doing it
# like Android does.  But the strings in this project also don't
# use it, so...
# \n (and other whitespace) unquoting is not done here.
# Also, "..." quotation is not supported and taken literally.
# (Because we have weird usages of some strings...).
# FIXME: Rewrite strings.xml and this to be comprehensible/predictable...
sub android_unquote($)
{
    my ($s) = @_;
    $s =~ s(\\([\\\'\"]))($1)g; # only do \\, \', \"
    return $s;
}

sub lang_order($)
{
    my ($x) = @_;
    return 0 if $x eq '';
    return 0 if $x eq $lang_default;   # default language
    return 1 if $x =~ m(^en\b);  # then all Englishes
    return 2; # and finally everything else
}

sub lang_cmp($$)
{
    my ($x, $y) = @_;
    return (lang_order($x) <=> lang_order($y)) || (lc($x) cmp lc($y)) || ($x cmp $y);
}

sub lang_class($;$)
{
    my ($lang, $class) = @_;
    my $qlang = quote_html($lang);
    $lang = 'en' if ($lang eq $lang_default);
    $class //= '';
    if ($lang =~ m(^([a-z]{2})\b)) {
        return qq( lang="$1" class="lang$qlang $class" );
    }
    return qq( class="lang$qlang $class" );
}

sub make_xlat($)
{
    my ($C) = @_;
    my $title = get_string($C, 'app_name', '');
    my $xlat_email = get_string($C, 'xlat_email', '') // die "No xlat_email";

    my $wdc = get_string_array($C, 'weekday_choice_key');
    my $xlatabl = get_attr(get_string_array($C, 'weekday_choice_key'), 'translatable', '');

    # die Dumper($C->{resource}{string});
    my @item = (
        sort { $a->{uniq} <=> $b->{uniq} }
        grep { (get_attr($_, 'translatable', '') // 'true') eq 'true' }
        (values %{ $C->{resource}{string} }),
        (values %{ $C->{resource}{string_array} }),
    );

    my $qtitle = quote_html qq('$title' Translations\n);

    my %lang = ();
    for my $item (@item) {
        if ($item->{type} eq 'string') {
            for my $l (keys %{ lang_map($item->{text}) }) {
                $lang{$l} = 1;
            }
        }
    }

    my $t = '';
    $t .= qq(<!DOCTYPE html>\n);
    $t .= qq(<html lang="en">\n);
    $t .= qq(<head>\n);
    $t .= qq(<meta charset="utf-8">\n);
    $t .= qq(<title>$qtitle</title>\n);
    $t .= qq(<style>\n);
    $t .= qq(th, td { text-align: left; vertical-align: top; padding: 4px; }\n);
    $t .= qq(td.head { font-weight: bold; }\n);
    $t .= qq(p.preln { white-space: pre-line; font-style: italic; }\n);
    # $t .= qq(.small { color: read; font-size: 80\%; }\n);
    $t .= qq(input[type="text"] { width: 600px; border: 2px solid #ccc; }\n);
    $t .= qq(button { margin: 10px; }\n);
    $t .= qq(table { border-spacing: 0px; }\n);
    $t .= qq(tr.odd0 { background-color: #efe; }\n);
    $t .= qq(tr.odd1 { background-color: #eef; }\n);
    $t .= qq(textarea {
        border-color: 2px solid #ccc;
        width: 600px;
        white-space: pre;
        overflow-wrap: normal;
        overflow-x: scroll; }\n);
    $t .= qq(textarea.req:placeholder-shown, input.req:placeholder-shown {
        background-color: #fee;
        border-color: #f00 }\n);
    $t .= qq(textarea.meta { width: 50%; min-width: 600px; }\n);
    $t .= qq(input.meta { width: 50%; min-width: 600px }\n);

    for my $l ('new', sort lang_cmp keys %lang) {
        my $ql = quote_html($l);
        $t .= qq(input[type="checkbox"]#l$ql:not(:checked) ~ form td.lang$ql { display: none }\n);
    }

    $t .= qq(</style>\n);
    $t .= qq(</head>\n);
    $t .= qq(<body>\n);
    $t .= qq(<h1>$qtitle</h1>\n);

    $t .= qq(<p>You can fix translations or add a new language here.
        Then click to send a patch (at the bottom of the page).</p>\n);

    for my $l ('new', sort lang_cmp keys %lang) {
        my $ql = quote_html($l);
        $t .= qq(<input type="checkbox" id="l$ql" checked="checked" /><label for="l$ql">$ql</label>\&nbsp;\n);
    }
    $t .= qq(<form action="mailto:$xlat_email?subject=$title Translations"
        method="POST" enctype="application/x-www-form-urlencoded">\n);

    $t .= qq(<table>\n);

    $t .= qq(<tr><td>.</td><td>.</td>\n);
    $t .= qq(<td).lang_class('new').
          qq(><input name="lang_new" class="req" tabindex="1" placeholder="new langcode (e.g. 'ee', 'kl-GL', ...)" type="text" value=""/>).
          qq(</td>);
    for my $l (sort lang_cmp keys %lang) {
        my $ql = quote_html($l);
        $t .= qq(<td).lang_class($l, 'head').qq(>$ql</th>);
    }
    $t .= qq(</tr>\n);

    my $trodd = 0;
    my $ti0 = 0;
    for my $item (@item) {
        my $var_len    = ((get_attr($item, 'varLen',     '') || 'false') eq 'true');
        my $miss_ok    = ((get_attr($item, 'ifEmpty',    '') || 'error') eq 'drop');
        my $keep_empty = ((get_attr($item, 'ifEmpty',    '') || 'error') eq 'keep');
        my $in_class = join(" ", ($keep_empty || $miss_ok) ? () : "req");
        my @it = ();
        if ($item->{type} eq 'string') {
            @it = ($item);
        }
        elsif ($item->{type} eq 'string_array') {
            my $cnt = scalar(@{ $item->{child}{item} // [] });
            if ($var_len) {
                my $it = { name => $item->{name}.'*' };
                @it = ($it);
                for my $i (0..$cnt-1) {
                    my $c = $item->{child}{item}[$i];
                    for my $fn (keys %$c) {
                        $it->{text}{$fn} .= "$c->{$fn}{text}\n";
                    }
                }
            }
            else {
                for my $i (0..$cnt-1) {
                    my $c = $item->{child}{item}[$i];
                    push @it, {
                        cnt => $cnt,
                        seq => $i,
                        name => $item->{name},
                        text => { map { ($_ => $c->{$_}{text}) } keys %$c },
                    };
                }
            }
        }
        next unless @it;

        $trodd = 1-$trodd;

        # comment
        my $have_comment = 0;
        for my $l (sort lang_cmp keys %lang) {
            if (my $com = get_lang($item->{com}, $l, '')) { if ($com !~ m(^<)) {
                $have_comment = 1;
                last;
            }}
        }
        if ($have_comment) {
            $t .= qq(<tr class="odd$trodd"><th></th><th></th>\n);
            my ($l) = sort lang_cmp keys %lang; # only use first language (the default)
            my $colspan = scalar(keys %lang) + 1;

            my $ql = quote_html($l);
            $t .= qq(<td colspan="$colspan">);
            if (my $com = get_lang($item->{com}, $l, '')) { if ($com !~ m(^<)) {
                my $qcom = quote_html($com);
                $t .= qq(<p class="preln">$qcom</p>);
            }}
            $t .= qq(</td>);

            $t .= qq(</tr>);
        }

        # stuff:
        for my $it (@it) {
            $ti0++;
            my ($kind, $_txt) = export_newline(get_lang($it->{text}, '', ''));
            my $name = $it->{name};
            $kind = '*' if $name =~ s([*]$)();
            $name.= $kind;

            my $qname = quote_html($name);
            my $qph = $qname;
            my $qseq = quote_html($it->{seq} // '');
            if (!$it->{cnt}) {
                $t .= qq(<tr class="odd$trodd"><th class="small">$qname</th><th>$qseq</th>\n);
            }
            elsif ($it->{seq} == 0) {
                $t .= qq(<tr class="odd$trodd"><th rowspan="$it->{cnt}" class="small">$qname</th><th>$qseq</th>\n);
                $qph .= " 0";
            }
            else {
                $t .= qq(<tr class="odd$trodd"><th>$qseq</th>\n);
                $qph .= " $qseq";
            }

            my $ti1 = 0;
            my $row_cnt2_default = undef;
            my $qtxt_default = undef;
            for my $l (sort lang_cmp keys %lang) {
                $ti1++;
                my $ti = $ti0 + ($ti1 * 20000);
                my $tj = $ti + 10000;

                my $ql = quote_html($l);
                my $seq = $it->{seq};
                my $ll = $l eq $lang_default ? '_' : $l;

                my ($_kind, $txt) = export_newline(get_lang($it->{text}, $l, ''));

                my $qid = quote_html($name.(defined($seq) ? ".$seq" : "").".$ll");
                my $qin = quote_html($name.(defined($seq) ? ".$seq" : "").".*");

                my $row_cnt = 1+($txt =~ tr/\n/\n/);

                if ($var_len && ($row_cnt < 10)) {
                    $row_cnt = 10;
                }

                my $row_cnt2 = $row_cnt;
                if ($row_cnt > 1) {
                    unless ($var_len || $kind) {
                        $txt =~ s(^(.+)$)(wrap_line($1,50))egm;
                        $txt =~ s(\s+$)()s;
                    }
                    $row_cnt2 = 1+($txt =~ tr/\n/\n/);
                    $row_cnt2 = $row_cnt if $row_cnt2 < $row_cnt;
                    $row_cnt2_default //= $row_cnt2;
                }

                my $qtxt = quote_html(android_unquote($txt));
                $qtxt_default //= $qtxt;
                if ($keep_empty) {
                    $qph = '';
                }
                elsif (!$var_len && $miss_ok && $it->{cnt}) {
                    $qph = '';
                }
                elsif ($miss_ok && ($qtxt_default // '') ne '') {
                    $qph = $qtxt_default;
                }

                if ($ti1 == 1) {
                    $t .= qq(<td).lang_class('new').qq(>\n);
                    if ($row_cnt > 1) {
                        $t .= qq(<textarea name="$qin" class="$in_class" tabindex="$ti" placeholder="$qph" rows="$row_cnt2_default"></textarea>\n);
                    }
                    else {
                        $t .= qq(<input name="$qin" class="$in_class" tabindex="$ti" placeholder="$qph" type="text" value=""/>);
                    }
                    $t .= qq(</td>\n);
                }
                $t .= qq(<td).lang_class($l).qq(>\n);
                if ($row_cnt > 1) {
                    $t .= qq(<textarea name="$qid" class="$in_class" tabindex="$tj" placeholder="$qph" rows="$row_cnt2">$qtxt</textarea>\n);
                }
                else {
                    $t .= qq(<input name="$qid" class="$in_class" tabindex="$tj" placeholder="$qph" type="text" value="$qtxt" />\n);
                }
                $t .= qq(</td>\n);
            }
            $t .= qq(</tr>\n);
        }
    }
    $t .= qq(</table>\n);
    $t .= qq(<p>If you want credit for your translation in a Git commit,
    then please give a name or pseudonym.  If empty, you won't be mentioned.<br>
    <input name="meta_name" value="" placeholder="Your Name" class="meta"/></p>\n);
    $t .= qq(<p>Any comments or suggestions or questions?<br>
    <textarea name="meta_comment" placeholder="Comment" class="meta"
    rows="5"></textarea></p>\n);
    $t .= qq(<button type="submit" value="Submit">Submit Translations by E-Mail</button>\n);
    $t .= qq(<p>NOTE: Please do not edit or reformat the text in the e-mail before ).
          qq(sending, but just send the raw text as is.</p>\n);
    $t .= qq(</form>\n);
    $t .= qq(</body>\n);
    $t .= qq(</html>\n);

    if ($do_gz) {
        write_file_gz("$C->{top_dir}/TRANSLATE.html.gz", $t);
    } else {
        write_file("$C->{top_dir}/TRANSLATE.html", $t);
    }
}

######################################################################

my $C = {};
init_dirs($C);

learn_resources($C);

# print Dumper($C);

# Enums
my $M = make_enums($C);
{
    my $t = make_enum_kotlin($C, $M);
    write_file(
        "$C->{java_dir}/AutoResource.kt",
        "// $auto_text\n".$t);
}

# Themes: it does not seem to be possible to do this dynamically, so we need
# to combine multiple dimensions of switches into a flat theme zoo.
{
    my $T = make_themes($C, $M);
    write_file(
        "$C->{res_dir}/values/auto-styles.xml", $T->{style});
    write_file(
        "$C->{java_dir}/AutoTheme.kt",
        "// $auto_text\n".$T->{kotlin});
}

# View bindings, because the bindView feature did not reliably work
# for me, and it is obscure what goes wrong (I just get an 'unresolved
# reference' from Kotlin, but the generated .java file exists, right
# next to the other binding .java files.  Kotlin seems to see about
# 2/3s of my files, with no indication why the others are not shown.
# Source XML looks very similar, maybe it doesn't like the name?
# It is also very badly documented as usual => just implement it in Perl
# (and generate Kotlin, not Java).
# Currently, we'll dump everything into one file into the main package to
# minimise hassle to use.
{
    my $t = make_binding($C, $C->{pack});
    write_file(
        "$C->{java_dir}/AutoBinding.kt",
        "// $auto_text\n".$t);
}

# Metadata description and Readme
make_metadata($C);

# Translation page (HTML)
make_xlat($C)
